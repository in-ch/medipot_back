name: CI/CD Docker

# 트리거를 수행할 브랜치를 지정합니다.
on:
  push:
    branches: [ main ]

# 환경설정
env:
  DOCKER_IMAGE: ghcr.io/${{ github.actor }}/medipod-back
  VERSION: ${{ github.sha }}
  NAME: go_cicd

jobs:
  # 빌드 Job
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      # github repository에서 checkout
      - uses: actions/checkout@v2
      # docker build 수행
      - name: Set up docker buildx
        id: buildx
        uses: docker/setup-buildx-action@v1
      - name: Cache docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ env.VERSION }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      # GitHub 컨테이너 레지스트리에 로그인 후 빌드 & 푸시
      - name: Login to ghcr
        uses: docker/login-action@v1
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push
        id: docker_build
        uses: docker/build-push-action@v2
        with:
          builder: ${{ steps.buildx.outputs.name }}
          push: true
          tags: ${{ env.DOCKER_IMAGE }}:latest
  # 배포 Job
  deploy:
    needs: build  # build 후에 실행되도록 정의
    name: Deploy
    runs-on: [ label-go ] # AWS ./configure에서 사용할 label명
    steps:
      - name: Login to ghcr
        uses: docker/login-action@v1
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # .prod.env 파일 생성
      - name: Create .prod.env
        run: |
          echo "DB_HOST=${{ secrets.DB_HOST }}"
          echo "DB_PORT=${{ secrets.DB_PORT }}"
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}"
          
          echo "DB_HOST=${{ secrets.DB_HOST }}" >> .prod.env
          echo "DB_PORT=${{ secrets.DB_PORT }}" >> .prod.env
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> .prod.env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .prod.env
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> .prod.env
          echo "PORT=${{ secrets.PORT }}" >> .prod.env

          echo "PRIVATE_KEY=${{ secrets.PRIVATE_KEY }}" >> .prod.env
          echo "JWT_EXPIRATION_TIME=${{ secrets.JWT_EXPIRATION_TIME }}" >> .prod.env
          
          echo "S3_ACESS_KEY=${{ secrets.S3_ACESS_KEY }}" >> .prod.env
          echo "S3_SECRET_KEY=${{ secrets.S3_SECRET_KEY }}" >> .prod.env
          echo "AWS_REGION=${{ secrets.AWS_REGION }}" >> .prod.env

          echo "ROOT_ACCESS_KEY=${{ secrets.ROOT_ACCESS_KEY }}" >> .prod.env
          echo "ROOT_SECRET_KEY=${{ secrets.ROOT_SECRET_KEY }}" >> .prod.env

          echo "EMAIL_FROM=${{ secrets.EMAIL_FROM }}" >> .prod.env

          echo "KAKAO_API=${{ secrets.KAKAO_API }}" >> .prod.env
          echo "KAKAO_API_REFRESH=${{ secrets.KAKAO_API_REFRESH }}" >> .prod.env
          echo "KAKAO_API_KEY=${{ secrets.KAKAO_API_KEY }}" >> .prod.env

          echo "NAVER_API=${{ secrets.NAVER_API }}" >> .prod.env

          echo "NOTION_API_KEY=${{ secrets.NOTION_API_KEY }}" >> .prod.env
          echo "NOTION_LOCATION_REGISTRATION=${{ secrets.NOTION_LOCATION_REGISTRATION }}" >> .prod.env
          echo "NOTION_CONSULT_REGISTRATION=${{ secrets.NOTION_CONSULT_REGISTRATION }}" >> .prod.env
          echo "NOTION_REPORT_REGISTRATION=${{ secrets.NOTION_REPORT_REGISTRATION }}" >> .prod.env
          echo "NOTION_LOCATION_INQUIRY_REGISTRATION=${{ secrets.NOTION_LOCATION_INQUIRY_REGISTRATION }}" >> .prod.env
          echo "NOTION_REQUEST_LICENSE=${{ secrets.NOTION_REQUEST_LICENSE }}" >> .prod.env
         
          echo "NCP_ACCESS_KEY=${{ secrets.NCP_ACCESS_KEY }}" >> .prod.env
          echo "NCP_SECRET_KEY=${{ secrets.NCP_SECRET_KEY }}" >> .prod.env
          echo "NCP_SERVICE_ID=${{ secrets.NCP_SERVICE_ID }}" >> .prod.env

        
      # 3000 -> 80 포트로 수행하도록 지정
      - name: Docker run
        run: |
          docker stop ${{ env.NAME }} && docker rm ${{ env.NAME }} && docker rmi ${{ env.DOCKER_IMAGE }}:latest
          docker run -d -p 80:4000 --name go_cicd --restart always ${{ env.DOCKER_IMAGE }}:latest
